/**
 * @file digestWatcher.js
 * @description Watches OpenClaw agent workspaces for new digest files and auto-emails them.
 */

const fs = require('fs');
const path = require('path');
const nodemailer = require('nodemailer');
const { execSync } = require('child_process');

class DigestWatcher {
  constructor() {
    this.watchedFiles = new Set();
    this.checkInterval = 30000; // Check every 30 seconds
    this.intervalId = null;
    this.workspacePath = '/home/sjpilche/projects/openclaw-v1/workspaces';
    this.recipient = 'steve.j.pilcher@gmail.com';
  }

  start() {
    console.log('[DigestWatcher] Starting digest file watcher...');
    console.log(`[DigestWatcher] Watching: ${this.workspacePath}`);
    console.log(`[DigestWatcher] Check interval: ${this.checkInterval / 1000}s`);
    console.log(`[DigestWatcher] Recipient: ${this.recipient}`);

    // Check immediately on start
    this.checkForNewDigests();

    // Then check periodically
    this.intervalId = setInterval(() => {
      this.checkForNewDigests();
    }, this.checkInterval);

    console.log('[DigestWatcher] ‚úÖ Watcher started');
  }

  stop() {
    if (this.intervalId) {
      clearInterval(this.intervalId);
      this.intervalId = null;
      console.log('[DigestWatcher] Watcher stopped');
    }
  }

  checkForNewDigests() {
    try {
      // Find all digest-*.md files in workspace subdirectories via WSL
      const command = `wsl.exe bash -c "find ${this.workspacePath} -name 'digest-*.md' -type f 2>/dev/null"`;
      const output = execSync(command, { encoding: 'utf8' });

      const files = output.trim().split('\n').filter(f => f);

      for (const filePath of files) {
        if (!this.watchedFiles.has(filePath)) {
          console.log(`[DigestWatcher] üìÑ New digest found: ${filePath}`);
          this.handleNewDigest(filePath);
          this.watchedFiles.add(filePath);
        }
      }
    } catch (error) {
      console.error('[DigestWatcher] Error checking for digests:', error.message);
    }
  }

  async handleNewDigest(filePath) {
    try {
      // Extract date from filename (digest-YYYY-MM-DD.md)
      const filename = path.basename(filePath);
      const dateMatch = filename.match(/digest-(\d{4}-\d{2}-\d{2})\.md/);
      const date = dateMatch ? dateMatch[1] : 'Unknown Date';

      // Read file content via WSL
      const command = `wsl.exe bash -c "cat '${filePath}'"`;
      const content = execSync(command, { encoding: 'utf8' });

      if (!content || content.trim().length === 0) {
        console.log('[DigestWatcher] ‚ö†Ô∏è  Digest file is empty, skipping');
        return;
      }

      // Send email
      await this.sendDigestEmail(date, content);

      console.log(`[DigestWatcher] ‚úÖ Digest emailed successfully: ${filename}`);
    } catch (error) {
      console.error('[DigestWatcher] Failed to handle digest:', error.message);
    }
  }

  async sendDigestEmail(date, content) {
    const host = process.env.SMTP_HOST;
    const port = parseInt(process.env.SMTP_PORT || '587', 10);
    const user = process.env.SMTP_USER;
    const pass = process.env.SMTP_PASS;
    const from = process.env.SMTP_FROM || user;

    if (!host || !user || !pass) {
      throw new Error('SMTP not configured');
    }

    const transporter = nodemailer.createTransport({
      host,
      port,
      secure: port === 465,
      auth: { user, pass },
    });

    // Convert markdown to basic HTML for better email rendering
    const htmlContent = content
      .replace(/^### (.+)$/gm, '<h3>$1</h3>')
      .replace(/^## (.+)$/gm, '<h2>$1</h2>')
      .replace(/^# (.+)$/gm, '<h1>$1</h1>')
      .replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>')
      .replace(/\[(.+?)\]\((.+?)\)/g, '<a href="$2">$1</a>')
      .replace(/^- (.+)$/gm, '‚Ä¢ $1')
      .replace(/^\d+\. /gm, '')
      .replace(/\n\n/g, '</p><p>')
      .replace(/\n/g, '<br>');

    const htmlBody = `
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<style>
body { font-family: system-ui, -apple-system, sans-serif; line-height: 1.6; color: #333; max-width: 700px; margin: 0 auto; padding: 20px; }
h1 { color: #2563eb; border-bottom: 2px solid #2563eb; padding-bottom: 10px; }
h2 { color: #1e40af; margin-top: 30px; }
h3 { color: #1e3a8a; margin-top: 25px; }
a { color: #2563eb; text-decoration: none; }
a:hover { text-decoration: underline; }
p { margin: 10px 0; }
</style>
</head>
<body>
<p>${htmlContent}</p>
<hr style="margin-top: 40px; border: none; border-top: 1px solid #ddd;">
<p style="font-size: 12px; color: #666;">
Generated by ClawOps Daily Digest Agent |
<a href="https://github.com/anthropics/claude-code">Claude Code</a>
</p>
</body>
</html>
    `.trim();

    const info = await transporter.sendMail({
      from,
      to: this.recipient,
      subject: `Daily Tech & AI Digest - ${date}`,
      text: content,
      html: htmlBody,
    });

    console.log(`[DigestWatcher] üìß Email sent (messageId: ${info.messageId})`);
  }
}

module.exports = { DigestWatcher };
